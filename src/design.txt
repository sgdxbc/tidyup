For the all time, the two high level design goals are: ensure high performance
on both client and replica sides, and protocol implementation should be reusable
for benchmark and testing (simulation).

High performance replica. We don't consider concurrent-accessible replica state
as a pratical approach, so the core replica logic will always be executed on a
single thread. Additional threads are set up and the following tasks are 
expected to be "offloaded" from main thread:
* Receive and send packets
* Serialize and deserialize packets
* Sign and verify message signatures

High performance client. It is common that large number of clients are 
concurrent running on the same machine (so we don't need to implement client 
that support issuing concurrent requests). So we don't maximize performance of
a client with multiple threads, instead we need to maximize performance of
multiple client with single thread. The transport layer of client must be 
runnable with single thread and support multiplexing for both messages and 
timers.

Simulation. Everything in simulation suppose to happen in single thread 
sequentially so it is easy to reason about. It need to support working with
multiple types of receivers (at least two in most cases, the client and replica
type of a protocol). It requires cooperative receivers, yield the thread when
no further progress can happen, instead of looping forever.

About timer. As the convention from specpaxos, protocols use one-shot cancelable
timers. In specpaxos and the later C++ codebases, replica state `this` get
captured into timer closure and get mutated on timeout, which is obviously not
the way Rust works. An explicit `this` argument (along with a context argument
so allow e.g. set the timer again) passed into closure looks promising, but in
case of simulation, multiple receiver types means multiple closure types, each
accepts different "`this`". It seems necessary to switch to poll mode to 
workaround callback-related problems.

About "driver". Receivers driving by transport layer is usually not a complete 
program. In the case of client-side program, a driving logic is needed to handle 
operation results and issue more operations if needed. In the case of test
cases, another driving logic is needed to modify simulated network during the
progress of protocol, e.g., partition/heal. These reaction logics are registered
as callback into transport in specpaxos, which has several problems:

* Even in C++ where closure captured is unlimited, callback-based code is hard
to understand, unfriendly to newcomers, which is especially bad for test cases
* Similar to timer callback, the type of driver, i.e., the set of states that
may be accessed in driving logic, must appear in closure signature to avoid
overlapping mutable borrowing. This is even worse than timer case, because 
driving logic normally does not have a type

To solve these problems, the transport layer may also need to switch to poll 
mode. In fact, in current version transport layer is almost gone, some becomes
into receivers, and some becomes into executable directly.

[WIP]