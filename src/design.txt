For the all time, the two high level design goals are: ensure high performance
on both client and replica sides, and protocol implementation should be reusable
for benchmark and testing (simulation).

High performance replica. We don't consider concurrent-accessible replica state
as a pratical approach, so the core replica logic will always be executed on a
single thread. Additional threads are set up and the following tasks are 
expected to be "offloaded" from main thread:
* Receive and send packets
* Serialize and deserialize packets
* Sign and verify message signatures

High performance client. It is common that large number of clients are 
concurrent running on the same machine (so we don't need to implement client 
that support issuing concurrent requests). So we don't maximize performance of
a client with multiple threads, instead we need to maximize performance of
multiple client with single thread. The transport layer of client must be 
runnable with single thread and support multiplexing for both messages and 
timers.

Simulation. Everything in simulation suppose to happen in single thread 
sequentially so it is easy to reason about. It need to support working with
multiple types of receivers (at least two in most cases, the client and replica
type of a protocol). It requires cooperative receivers, yield the thread when
no further progress can happen, instead of looping forever.

About timer. As the convention from specpaxos, protocols use one-shot cancelable
timers. In specpaxos and the later C++ codebases, replica state `this` get
captured into timer closure and get mutated on timeout, which is obviously not
the way Rust works. An explicit `this` argument (along with a context argument
so allow e.g. set the timer again) passed into closure looks promising, but in
case of simulation, multiple receiver types means multiple closure types, each
accepts different "`this`". It seems necessary to switch to poll mode to 
workaround callback-related problems.

Short summary.
* For replicas, they should be able to switch between offloading mode and inline
mode, for benchmark and simulation respectively.
* For replicas, they should be able to switch between exclusive mode and 
cooperative mode, for benchmark and simulation respectively.
* For everything, they should be able to receive message and timer notification
from both benchmark and simulated environment. They should also send message and
manage timers in such fashion.
* We want a poll-mode interface to avoid receiver types appear in their 
interface method signatures. This also means receivers should actively detect
external events (as while as actively create external events) instead of 
passively providing certain callbacks.

[WIP]